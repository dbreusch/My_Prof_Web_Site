<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>Computing</title>
  <!-- Bootstrap style sheets -->
  <link rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
    integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
    crossorigin="anonymous">

  <!-- Bootstrap scripts -->
  <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
    integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
    integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
    crossorigin="anonymous"></script>

  <!-- Google fonts -->
  <link
    href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap"
    rel="stylesheet">

  <!-- Font Awesome -->
  <script src="https://kit.fontawesome.com/c11f3b1a3f.js" crossorigin="anonymous"></script>

  <!-- jQuery and local javascript -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="index.js" charset="utf-8"></script>

  <!-- My CSS -->
  <link rel="stylesheet" href="css/styles.css">

</head>

<body>
  <!-- Navigation Bar -->
  <div data-include="nav-bar"></div>

  <!-- Title Section with name, affiliations -->
  <div data-include="contact-header"></div>

  <section class="white-section">
    <div class="container-fluid">
      <h2>
        Software
      </h2>

      <table class="table-entry">
        <tr>
          <th>
            Language
          </th>
          <th>
            Experience
          </th>
          <th>
            Recency
          </th>
          <th>
            Complexity
          </th>
        </tr>

        <tr>
          <td>Python</td>
          <td>⭐️⭐️⭐️⭐️⭐️</td>
          <td>⭐️⭐️⭐️⭐️⭐️</td>
          <td>⭐️⭐️⭐️</td>
        </tr>

        <tr>
          <td>Fortran</td>
          <td>⭐️⭐️⭐️</td>
          <td>⭐️⭐️⭐️⭐️</td>
          <td>⭐️⭐️</td>
        </tr>

        <tr>
          <td>Matlab</td>
          <td>⭐️⭐️⭐️⭐️⭐️</td>
          <td>⭐️⭐️⭐️⭐️</td>
          <td>⭐️⭐️⭐️</td>
        </tr>

        <tr>
          <td>C</td>
          <td>⭐️⭐️⭐️</td>
          <td>⭐️⭐️</td>
          <td>⭐️⭐️</td>
        </tr>

        <tr>
          <td>C++</td>
          <td>⭐️⭐️⭐️⭐️</td>
          <td>⭐️⭐️</td>
          <td>⭐️⭐️⭐️⭐️</td>
        </tr>

        <tr>
          <td>Perl</td>
          <td>⭐️⭐️</td>
          <td>⭐️</td>
          <td>⭐️</td>
        </tr>

        <tr>
          <td>LISP</td>
          <td>⭐️</td>
          <td>⭐️</td>
          <td>⭐️</td>
        </tr>

        <tr>
          <td>csh/tcsh</td>
          <td>⭐️⭐️⭐️⭐️⭐️</td>
          <td>⭐️⭐️⭐️⭐️⭐️</td>
          <td>⭐️</td>
        </tr>

        <tr>
          <td>bash</td>
          <td>⭐️⭐️</td>
          <td>⭐️⭐️⭐️⭐️⭐️</td>
          <td>⭐️</td>
        </tr>

        <tr>
          <td>Assembler</td>
          <td>⭐️⭐️⭐️⭐️</td>
          <td>⭐️</td>
          <td>⭐️⭐️</td>
        </tr>
      </table>
    </div>
  </section>

  <section class="white-section">
    <div class="container-fluid">

      <div class="std-paragraph">
        <p>
          The table above summarizes three overlapping aspects of
          my skills with various computing languages. These evaluations
          can be interpreted following the subjective thoughts below:
        </p>
        <ul>
          <li>
            Experience
            <p>
              How much time have I spent using the language?
            </p>
            <p>
              How long one has used a language is a basic metric for proficiency
              since skill normally grows with usage.
              Of course, length of usage doesn't guarantee quality of code but
              the two often go together.
            </p>
            <p>
              Experience also transfers to other languages even when one hasn't
              used the old one for awhile.
              Sometimes this leads to problems (like accidentally mixing syntaxes)
              but overall it's a definite benefit to be famiiliar with multiple languages.
              It encourages mental flexibility.
            </p>

          </li>
          <li>
            Recency
            <p>
              How recently have I been using the language?
            </p>
            <p>
              Familiarity in all skills normally drops off with the length of time
              since you used it last.
              The same is certainly true of programming languages.
              I spent a LOT of time with LISP when I needed it for a graduate
              school class -- but I haven't touched it since (1993/94!), so I
              doubt I'd be very good with it anymore.
            </p>
            <p>
              Likewise, I used COBOL some during my systems programming days at
              AT&T and was able to do some useful things with it. Nevertheless,
              I'd be near the front of the learning curve if I were to try to
              pick it up again today.
            </p>
            <p>
              On the other hand, I'm using Python a lot these days so it stays
              pretty fresh.
            </p>
          </li>
          <li>
            Complexity
            <p>
              How complex was my programming in this language?
            </p>
            <p>
              Complexity also matters when evaluating competency.
              I've done a LOT of shell scripting over the years but they've mostly
              been small, very task-focused efforts (likewise with Python).
              Complex tasks generally bring in bigger issues of how to best manage
              the code, how to break up large tasks (modularize, abstract) and similar
              topics that don't come up with one-off, short codes.
            </p>
            <p>
              My Computer Science M.Sc. involved a large, complex C++ application
              (at least it seemed that way at the time!) and I learned a lot about C++
              and object-oriented programming from it.
            </p>
            <p>
              Working with the WRF model for 10+ years has exposed me to a lot of
              "legacy" Fortran and, even though I haven't changed a line of it, I
              have also learned some useful things about Fortran and organizing
              very large application code bases.
            </p>
          </li>
        </ul>
      </div>
    </div>
  </section>

  <section class="colored-section">
    <div class="container-fluid">
      <h2>
        Hardware/Platforms
      </h2>

      <div class="std-paragraph">
        <ul>
          <li>
            Apple: OS X / macOS (1985; 1994 to present)
            <p>
              I remember an Apple II in my high school library but I didn't
              really use Apple products until my robotics class as an undergrad.
              That was an early Mac and we interfaced it to real-world, physical
              objects (like stepper motors) to learn about robotics.
            </p>
            <p>
              I encountered Macs next during grad school. Research groups at
              UNH and Penn State favored Macs over PCs and I never really looked
              back (they also both had workstation-class machines from Sun and SGI,
              but that's another story).
            </p>
            <p>
              I've spent a lot of time with macOS (and OS X before it) over the
              years, both as a user and as an administrator (mostly of my own machines).
              The latter was usually geared towards customizing my environment to
              suit my research needs with occasional forays into system upgrades
              and similar endeavors.
            </p>
          </li>
          <li>
            PC: Windows (since ca. 1991)
            <p>
              I have used various versions of Windows on my personal PC for more
              than 25 years. The oldest machine replaced an Atari and was bought
              as a complete system. That was followed by a laptop, another
              off-the-shelf, then I started building my own.
              While I have written two Master's theses, a dissertation and multiple
              journal articles on Windows, I haven't done
              a lot of programming or research on this platform.
              The heavy lifting of figure creation, data analysis, etc., way
              almost all done elsewhere.
            </p>
          </li>
          <li>
            High-performance computing (since ca. 2002)
            <p>
              I have been an HPC user of machines at Penn State and NCAR since
              partway through my Ph.D. program.
              I have used five (I think) generations of supercomputers at NCAR (and
              one at UC-Boulder) with a range of operating systems and job queuing
              systems.
            </p>
          </li>
          <li>
            PC: Linux (since ca. 2002)
            <p>
              Since late in my Ph.D. program, I've been administering (and using!)
              two Linux-based data servers based on off-the-shelf PC components.
              I have used both RedHat and Fedora (going Fedora, RedHat, back to
              Fedora) and have a reasonable familiarity with what needs to be done
              to move systems from one network to another (as I've moved about
              the country) and to keep the system secure.
            </p>
          </li>
          <li>
            Apple: iOS (since 2008 as user, 2019 as coder)
            <p>
              I've been an iPhone user for a long time (though not quite from
              the beginning).
              I have recently started learning how to write iOS apps using Xcode.
            </p>
          </li>
          <li>
            IBM: System 370, MVS/XA, System 390, MVS/ESA (1986-1994)
            <p>
              My first job after college was as an MVS Systems Programmer at an
              AT&T manufacturing facility, i.e., "big iron" mainframes.
              I worked on both software (operating systems) and hardware (CPUs,
              disk drives, tape drives, even some older stuff) and learned a lot
              about how to manage a system safely and efficiently.
            </p>
          </li>
        </ul>
      </div>

    </div>
  </section>

  <div data-include="footer"></div>

</body>

</html>
